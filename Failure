const mocha = require('mocha');
const Spec = mocha.reporters.Spec;
const Base = mocha.reporters.Base;

class CustomSummary extends Spec {
  constructor(runner) {
    super(runner);

    const failures = [];
    let failCount = 0;

    runner.on('fail', (test, err) => {
      failCount++;
      failures.push({ count: failCount, test, err, indent: Base.indents });
    });

    runner.once('end', () => {
      if (failures.length === 0) return;

      console.log('\n=== Custom Failure Summary ===\n');
      failures.forEach(({ count, test, err, indent }) => {
        const ind = '  '.repeat(indent);
        console.log(`${ind}(${count}) FAIL: ${test.fullTitle()}`);
        console.log(`${ind}    ${err.message}\n`);
      });
    });
  }
}

====== DataTables =====
module.exports = CustomSummary;

function syncDropdownWithTable(table, dropdownId, skipFixedCount = 2) {
    const colOrder = table.colReorder.order(); // Full current column order (original idxs)
    const dropdown = document.getElementById(dropdownId);
    const allItems = Array.from(dropdown.children); // Existing dropdown items

    // Build new dropdown
    const fragment = document.createDocumentFragment();

    colOrder.forEach((originalIdx, displayIdx) => {
        // Skip fixed columns (non-reorderable)
        if (displayIdx < skipFixedCount) return;

        const column = table.column(originalIdx);
        if (!column.visible()) return;

        // Match dropdown item with the original column index
        const item = allItems.find(el => parseInt(el.dataset.colIdx) === originalIdx);
        if (item) fragment.appendChild(item);
    });

    // Replace dropdown content with reordered list
    dropdown.innerHTML = '';
    dropdown.appendChild(fragment);
}

==== D3 ====
function drawChart(el, width, height, data) {
  const svg = d3.select(el).select("svg");
  const chart = svg.select("g.chart-content"); // your main group

  // Update scales based on new width/height
  xScale.range([0, width]);
  yScale.range([height, 0]);

  // DATA JOIN
  const line = d3.line()
    .x((d, i) => xScale(i))
    .y(d => yScale(d));

  // Re-bind and update path
  const path = chart.selectAll("path.line").data([data]);

  path.join("path")
    .attr("class", "line")
    .attr("d", line)
    .attr("fill", "none")
    .attr("stroke", "steelblue");
}

function createResponsiveChart(el, data, drawFn) {
  const resizeState = new WeakMap();
  const visibilityState = new WeakMap();
  const drawnState = new WeakMap();

  // Create and inject SVG if missing
  let svg = d3.select(el).select("svg");
  if (svg.empty()) {
    svg = d3.select(el)
      .append("svg")
      .attr("preserveAspectRatio", "xMinYMin meet")
      .style("width", "100%")
      .style("height", "100%");
  }

  function maybeRedraw(target) {
    const size = resizeState.get(target);
    const isVisible = visibilityState.get(target);

    if (!isVisible || !size || size.width === 0 || size.height === 0) return;

    const key = `${Math.round(size.width)}x${Math.round(size.height)}`;
    if (drawnState.get(target) === key) return; // skip identical draw

    drawnState.set(target, key);

    requestAnimationFrame(() => {
      svg.attr("viewBox", `0 0 ${size.width} ${size.height}`);
      drawFn(target, svg, size.width, size.height, data);
    });
  }

  const ro = new ResizeObserver(entries => {
    for (const entry of entries) {
      resizeState.set(entry.target, entry.contentRect);
      maybeRedraw(entry.target);
    }
  });

  const io = new IntersectionObserver(entries => {
    for (const entry of entries) {
      visibilityState.set(entry.target, entry.isIntersecting);
      maybeRedraw(entry.target);
    }
  }, { threshold: 0.1 });

  // Start observing
  ro.observe(el);
  io.observe(el);
}

const zoom = d3.zoom()
  .scaleExtent([1, 10])
  .on("zoom", ({ transform }) => {
    svg.select("g.chart").attr("transform", `translate(${margin.left + transform.x},${margin.top}) scale(${transform.k},1)`);
  });

svg.call(zoom);


function applyCursorLogic(label) {
  const input = label.querySelector('.btn-check');
  if (!input) return;

  const updateCursor = () => {
    label.style.cursor = input.disabled ? 'not-allowed' : '';
  };

  // Initial state
  updateCursor();

  // Watch for `disabled` attribute changes
  const attrObserver = new MutationObserver(updateCursor);
  attrObserver.observe(input, { attributes: true, attributeFilter: ['disabled'] });
}

// Initial pass for existing labels
document.querySelectorAll('label.btn').forEach(applyCursorLogic);

// Watch for future additions
const rootObserver = new MutationObserver((mutations) => {
  mutations.forEach((mutation) => {
    mutation.addedNodes.forEach((node) => {
      if (!(node instanceof HTMLElement)) return;

      // Case 1: a new <label class="btn"> directly added
      if (node.matches('label.btn')) {
        applyCursorLogic(node);
      }

      // Case 2: container added that has one or more labels inside
      node.querySelectorAll?.('label.btn').forEach(applyCursorLogic);
    });
  });
});

rootObserver.observe(document.body, { childList: true, subtree: true });

document.addEventListener('click', function (e) {
  const label = e.target.closest('label.btn');
  if (!label) return;

  const input = label.querySelector('.btn-check');
  if (input?.disabled) {
    e.stopImmediatePropagation(); // prevents Bootstrap toggling .active
    e.preventDefault();
  }
}, true); // useCapture = true to intercept before Bootstrap's handler

WITH a_avg AS (
  SELECT
    section,
    date_trunc('minute', timestamp) - INTERVAL '1 minute' * EXTRACT(MINUTE FROM timestamp)::int % 10 AS time_bucket,
    AVG(val1) AS avg_val1,
    AVG(val2) AS avg_val2,
    AVG(val3) AS avg_val3
  FROM table_a
  WHERE timestamp BETWEEN '2025-07-25 00:00:00' AND '2025-07-25 23:59:59'
  GROUP BY section, time_bucket
),
b_avg AS (
  SELECT
    section,
    date_trunc('minute', timestamp) - INTERVAL '1 minute' * EXTRACT(MINUTE FROM timestamp)::int % 10 AS time_bucket,
    AVG(valx) AS avg_valx,
    AVG(valy) AS avg_valy
  FROM table_b
  WHERE timestamp BETWEEN '2025-07-25 00:00:00' AND '2025-07-25 23:59:59'
  GROUP BY section, time_bucket
)
SELECT
  a.section,
  a.time_bucket,
  a.avg_val1,
  a.avg_val2,
  a.avg_val3,
  b.avg_valx,
  b.avg_valy
FROM a_avg a
JOIN b_avg b ON a.section = b.section AND a.time_bucket = b.time_bucket
ORDER BY a.section, a.time_bucket;

$fieldsA = ['traffic_in', 'traffic_out', 'status_code'];
$fieldsB = ['cpu_usage', 'mem_usage'];

function buildAvgSelect($fields, $tableAlias = '') {
    $selectParts = [];
    foreach ($fields as $field) {
        $selectParts[] = "AVG({$tableAlias}{$field}) AS avg_{$field}";
    }
    return implode(",\n    ", $selectParts);
}

$selectA = buildAvgSelect($fieldsA);
$selectB = buildAvgSelect($fieldsB);

$sql = "
WITH a_avg AS (
  SELECT
    device_id,
    date_trunc('minute', timestamp) - INTERVAL '1 minute' * EXTRACT(MINUTE FROM timestamp)::int % 10 AS time_bucket,
    {$selectA}
  FROM device_traffic_log
  WHERE timestamp BETWEEN :start AND :end
  GROUP BY device_id, time_bucket
),
b_avg AS (
  SELECT
    device_id,
    date_trunc('minute', timestamp) - INTERVAL '1 minute' * EXTRACT(MINUTE FROM timestamp)::int % 10 AS time_bucket,
    {$selectB}
  FROM device_perf_log
  WHERE timestamp BETWEEN :start AND :end
  GROUP BY device_id, time_bucket
)
SELECT
  a.device_id,
  a.time_bucket,
  {$selectA},
  {$selectB}
FROM a_avg a
JOIN b_avg b ON a.device_id = b.device_id AND a.time_bucket = b.time_bucket
ORDER BY a.device_id, a.time_bucket;
";


<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Drag Snap to cm Grid</title>
  <style>
    body { margin: 0; font-family: sans-serif; }
    svg { border: 1px solid #aaa; }
    .draggable { cursor: move; fill: steelblue; }
  </style>
</head>
<body>

<svg id="map" width="800" height="600"></svg>

<script src="https://d3js.org/d3.v7.min.js"></script>
<script>
  // === CONFIG ===
  const mapWidth_cm = 40;  // User-defined width in cm
  const mapHeight_cm = 30; // User-defined height in cm

  const svg = d3.select("#map");
  const svgWidth_px = parseInt(svg.attr("width"));
  const svgHeight_px = parseInt(svg.attr("height"));

  // Conversion ratios
  const pxPerCmX = svgWidth_px / mapWidth_cm;
  const pxPerCmY = svgHeight_px / mapHeight_cm;
  const cmPerPxX = 1 / pxPerCmX;
  const cmPerPxY = 1 / pxPerCmY;

  // === DYNAMIC STEP ===
  const desiredSteps = 50;
  const stepX_cm = mapWidth_cm / desiredSteps;
  const stepY_cm = mapHeight_cm / desiredSteps;

  // === HELPER FUNCTIONS ===
  const pxToCm = (px, axis = 'x') => axis === 'x' ? px * cmPerPxX : px * cmPerPxY;
  const cmToPx = (cm, axis = 'x') => axis === 'x' ? cm * pxPerCmX : cm * pxPerCmY;

  function snapToGrid(cmValue, step) {
    return Math.round(cmValue / step) * step;
  }

  // === ICON ===
  const icon = svg.append("circle")
    .attr("class", "draggable")
    .attr("r", 10)
    .attr("cx", 100)
    .attr("cy", 100)
    .call(
      d3.drag().on("drag", function (event) {
        let rawX_px = event.x;
        let rawY_px = event.y;

        // Convert to cm
        let x_cm = pxToCm(rawX_px, 'x');
        let y_cm = pxToCm(rawY_px, 'y');

        // Snap in cm
        let snappedX_cm = snapToGrid(x_cm, stepX_cm);
        let snappedY_cm = snapToGrid(y_cm, stepY_cm);

        // Back to px
        let snappedX_px = cmToPx(snappedX_cm, 'x');
        let snappedY_px = cmToPx(snappedY_cm, 'y');

        // Apply
        d3.select(this)
          .attr("cx", snappedX_px)
          .attr("cy", snappedY_px);
      })
    );

  // === DEBUG CORNERS (OPTIONAL) ===
  [[0,0], [mapWidth_cm,0], [0,mapHeight_cm], [mapWidth_cm,mapHeight_cm]].forEach(([x, y]) => {
    svg.append("circle")
      .attr("cx", cmToPx(x, 'x'))
      .attr("cy", cmToPx(y, 'y'))
      .attr("r", 5)
      .attr("fill", "red");
  });

</script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Drag Snap with px-aware cm Steps</title>
  <style>
    body { margin: 0; }
    svg { border: 1px solid #ccc; background-color: #f9f9f9; }
    .draggable { fill: steelblue; cursor: grab; }
  </style>
</head>
<body>

<svg id="map" width="1000" height="750"></svg>

<script src="https://d3js.org/d3.v7.min.js"></script>
<script>
  // === CONFIGURABLE MAP SIZE ===
  const mapWidth_cm = 100;   // e.g., 100 cm wide
  const mapHeight_cm = 75;   // e.g., 75 cm tall

  const svg = d3.select("#map");
  const svgWidth_px = +svg.attr("width");
  const svgHeight_px = +svg.attr("height");

  // === CONVERSIONS ===
  const pxPerCmX = svgWidth_px / mapWidth_cm;
  const pxPerCmY = svgHeight_px / mapHeight_cm;
  const cmPerPxX = 1 / pxPerCmX;
  const cmPerPxY = 1 / pxPerCmY;

  // === DYNAMIC STEP BASED ON PIXEL TARGET ===
  const targetStep_px = 20; // snap every 20 pixels (regardless of resolution)
  const stepX_cm = targetStep_px * cmPerPxX;
  const stepY_cm = targetStep_px * cmPerPxY;

  const pxToCm = (px, axis = 'x') => axis === 'x' ? px * cmPerPxX : px * cmPerPxY;
  const cmToPx = (cm, axis = 'x') => axis === 'x' ? cm * pxPerCmX : cm * pxPerCmY;
  const snap = (val_cm, step_cm) => Math.round(val_cm / step_cm) * step_cm;

  // === DRAGGABLE ICON ===
  const icon = svg.append("circle")
    .attr("class", "draggable")
    .attr("r", 10)
    .attr("cx", cmToPx(10, 'x'))
    .attr("cy", cmToPx(10, 'y'))
    .call(d3.drag().on("drag", function (event) {
      let x_cm = pxToCm(event.x, 'x');
      let y_cm = pxToCm(event.y, 'y');

      let snappedX_cm = snap(x_cm, stepX_cm);
      let snappedY_cm = snap(y_cm, stepY_cm);

      d3.select(this)
        .attr("cx", cmToPx(snappedX_cm, 'x'))
        .attr("cy", cmToPx(snappedY_cm, 'y'));
    }));

  // === CORNER MARKERS ===
  const corners_cm = [
    [0, 0],
    [mapWidth_cm, 0],
    [0, mapHeight_cm],
    [mapWidth_cm, mapHeight_cm]
  ];

  corners_cm.forEach(([x_cm, y_cm]) => {
    svg.append("circle")
      .attr("cx", cmToPx(x_cm, 'x'))
      .attr("cy", cmToPx(y_cm, 'y'))
      .attr("r", 4)
      .attr("fill", "red");
  });

  // === OPTIONAL GRID DISPLAY ===
  for (let x_cm = 0; x_cm <= mapWidth_cm; x_cm += stepX_cm) {
    svg.append("line")
      .attr("x1", cmToPx(x_cm, 'x'))
      .attr("y1", 0)
      .attr("x2", cmToPx(x_cm, 'x'))
      .attr("y2", svgHeight_px)
      .attr("stroke", "#eee");
  }
  for (let y_cm = 0; y_cm <= mapHeight_cm; y_cm += stepY_cm) {
    svg.append("line")
      .attr("x1", 0)
      .attr("y1", cmToPx(y_cm, 'y'))
      .attr("x2", svgWidth_px)
      .attr("y2", cmToPx(y_cm, 'y'))
      .attr("stroke", "#eee");
  }
</script>
</body>
</html>
